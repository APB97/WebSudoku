@page "/printMultiple"

@using System.Globalization
@using WebSudoku.Extensions
@using WebSudoku.Shared
@using WebSudoku.Shared.General
@using WebSudoku.Shared.Sudoku

@implements IAsyncDisposable

@inject CountingSolver Solver
@inject Blanker Blanker
@inject Validator Validator
@inject IJSRuntime JS

<PageTitle>Web Sudoku - print multiple</PageTitle>

<div class="d-print-none">
    <button class="btn btn-danger" @onclick="boards.Clear">Clear all</button>
    <label for="width">Board width [%]</label>
    <InputSelect id="width" TValue="float" Value="boardWidthPercentage" ValueExpression="() => boardWidthPercentage" ValueChanged="UpdateBoardWidth">
        <option value="33,3333">33%</option>
        <option value="50">50%</option>
        <option value="100">100%</option>
    </InputSelect>
    <label for="boards-amount">Boards to generate</label>
    <InputNumber id="boards-amount" min="1" max="32" @bind-Value="boardsToGenerate" />
    <button disabled="@(generating ? "disabled" : null)" class="btn btn-primary" @onclick="GenerateBoards">Add @boardsToGenerate sudoku(s)</button>
    <button class="btn btn-secondary" onclick="print()">Print</button>
</div>

@if (generating)
{
    <div class="border border-2 border-info">Generating additional sudokus...</div>
}

<div class="d-flex flex-wrap">
    @foreach (var board in boards)
    {
        <div class="p-2" style="break-inside: avoid-page; width: @boardWidthPercentage.ToString(CultureInfo.InvariantCulture)%;">
            <table class="sudoku-table" style="border-spacing: 0px;">
                @for (int r = 0; r < Board.BoardSize; r++)
                {
                    <tr>
                        @for (int c = 0; c < Board.BoardSize; c++)
                        {
                            // these local variables are needed to cache position of Cell on the board
                            int row = r, column = c;
                            var value = board.GetValueAt((row, column));
                            string cellValue = value != 0 ? value.ToString() : string.Empty;
                            <td>
                                <Cell ReadOnly="true" HighlightClass="@null"
                                    Value="@cellValue"
                                    SwitchTypeOnFocus="false"
                                    />
                            </td>
                        }
                    </tr>
                }
            </table>
            <div class="d-print-none">
                <button class="btn btn-danger" @onclick="() => boards.Remove(board)">Remove board</button>
                <button class="btn btn-success" disabled="@(generating ? "disabled" : null)" @onclick="() => Regenerate(board)">Regenerate board</button>
            </div>
        </div>
    }
</div>

@code {
    private List<Board> boards = [];

    private bool generating;

    private float boardWidthPercentage = 100;

    private int boardsToGenerate = 4;

    private IJSObjectReference? utilities;

    protected override async Task OnInitializedAsync()
    {
        utilities = await JS.InvokeAsync<IJSObjectReference>("import", "./js/utilities.js");
        var setting = await utilities.GetSetting<string>("printMultiple_boardWidthPercentage");
        if (!float.TryParse(setting, CultureInfo.InvariantCulture, out var result)) return;
        boardWidthPercentage = result;
    }

    private async Task UpdateBoardWidth(float width)
    {
        boardWidthPercentage = width;
        if (utilities is null) return;
        await utilities.SetSetting("printMultiple_boardWidthPercentage", width);
    }

    private Task GenerateBoards() => GenerateBoards(boardsToGenerate);

    private async Task GenerateBoards(int amount)
    {
        generating = true;
        await Task.Run(async () =>
        {
            try
            {
                for (int i = 0; i < amount; i++)
                {
                    generating = true;
                    boards.Add(new Board(Solver, new RandomOptionOrder<int>(), Blanker, 40, 64));
                }
            }
            catch (Exception ex)
            {
                if (utilities is not null)
                {
                    await utilities.Alert(ex.Message);
                }
            }
            finally
            {
                generating = false;
            }
            StateHasChanged();
        });
    }

    private async Task Regenerate(Board board)
    {
        if (generating) return;
        var index = boards.FindIndex(b => b == board);
        if (index < 0) return;

        try
        {
            generating = true;
            boards[index] = new Board(Solver, new RandomOptionOrder<int>(), Blanker, 40, 64);
        }
        catch (Exception ex)
        {
            if (utilities is not null)
            {
                await utilities.Alert(ex.Message);
            }
        }
        finally
        {
            generating = false;
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (utilities is null) return;
        await utilities.DisposeAsync();
    }
}
