@page "/sudoku"
@using System.Linq
@using apb97.github.io.WebSudoku.Services.KeyDownHandling
@using apb97.github.io.WebSudoku.Shared
@using apb97.github.io.WebSudoku.Shared.General
@using apb97.github.io.WebSudoku.Shared.Serialization
@using apb97.github.io.WebSudoku.Shared.Sudoku

@inject CountingSolver Solver
@inject Blanker Blanker
@inject Validator SudokuValidator
@inject IJSRuntime JS
@inject StringLocalizer<Sudoku> Loc

@implements IAsyncDisposable

<SettingsProvider @ref="settingsProvider" />

<PageTitle>Web Sudoku - sudoku</PageTitle>

@if (ShouldRender())
{
    @if (!success)
    {
        <div class="d-flex flex-direction-var">
            <div class="div-main">
                <TimerDisplay @ref="timer" />
                @SudokuBoardFragment
            </div>
    
            @SudokuOptionsFragment
        </div>
    }
    else
    {
        @SudokuFinishedFragment
    }
}

@code {
    [CascadingParameter]
    public required MainLayout Layout { get; set; }

    private Board board = new Board();
    private const string SudokuStateKey = "sudokuState";
    private const string TimerStateKey = "timerState";

    private int targetBlanks = 35;
    private int attemptsToRemove = 4;

    private bool success = false;

    private TimeSpan? timePassed;

    private List<CellPosition> InvalidCells = new List<CellPosition>();

    private TimerDisplay? timer;

    private IJSObjectReference? module;
    private IJSObjectReference? utilitiesModule;

    private bool isMobile;
    private bool isFirefox;
    private string CellDefaultType = Cell.InputTypeText;

    private Cell[,] cells = new Cell[Board.BoardSize, Board.BoardSize];

    private string? lastSavedState;

    private string StatusMessage = string.Empty;

    private CancellationTokenSource cts = new();

    private SettingsProvider? settingsProvider;

    private SudokuCellKeyDownHandler? keyHandler;

    private RenderFragment SudokuBoardFragment => __builder =>
    {
        <table class="sudoku-table" style="border-spacing: 0px;">
            @for (int r = 0; r < Board.BoardSize; r++)
            {
                <tr>
                    @for (int c = 0; c < Board.BoardSize; c++)
                    {
                        // these local variables are needed to cache position of Cell on the board
                        int row = r, column = c;
                        <td>
                            <Cell @ref="cells[row, column]"
                                  ReadOnly="board.IsPredefined((row, column))"
                                  HighlightClass="@HighlightClassFor((row, column))"
                                  Value="@board.GetValueAsString((row, column))"
                                  OnKeyDown="k => HandleKeyDown(k, row + 1, column + 1)"
                                  SwitchTypeOnFocus="isMobile"
                                  DefaultType="@CellDefaultType" />
                        </td>
                    }
                </tr>
            }
        </table>
    };

    private string? HighlightClassFor(CellPosition cell)
    {
        return InvalidCells.Contains(cell) ? "error-highlight" : null;
    }

    private RenderFragment SudokuOptionsFragment => __builder =>
    {
        <div class="div-options d-print-none">
            <button class="btn btn-primary" @onclick="Save">@Loc["Save"]</button>
            <button class="btn btn-primary" @onclick="Load"
                    title="@(string.IsNullOrEmpty(lastSavedState) ? Loc["Previous save not found"] : null)"
                    disabled="@(string.IsNullOrEmpty(lastSavedState) ? "disabled" : null)">
                @Loc["Load"]
            </button>
            <button class="btn btn-purple" onclick="print()">@Loc["Print"]</button>
            <PrintSettings />

            <span class="alert alert-info position-sticky sticky-bottom-portrait @(string.IsNullOrEmpty(StatusMessage) ? "d-none" : null)"
                role="status">@StatusMessage</span>
        </div>
    };

    private RenderFragment SudokuFinishedFragment => __builder =>
    {
        <h1>@Loc["Success"]</h1>
        @if (timePassed.HasValue)
        {
            <p>@Loc["You finished with time"] @timePassed.</p>
        }
        <button class="btn btn-primary" @onclick="CreateNewBoard">@Loc["Play again"]</button>
    };

    protected override bool ShouldRender()
    {
        return Loc.IsReady;
    }

    protected override async Task OnInitializedAsync()
    {
        Layout.OnStateChanging += LoadResourcesAsync;
        await Loc.InitializeAsync(Layout.Culture);
        module = await JS.ImportAsync("./Pages/Sudoku.razor.js");
        if (module is not null)
            keyHandler = new SudokuCellKeyDownHandler(module, ProcessNonNavigatingInputAsync);
        if (module != null)
        {
            try
            {
                isMobile = await module.InvokeAsync<bool>("isMobile");
                isFirefox = await module.InvokeAsync<bool>("isFirefox");
            }
            catch
            {
                isMobile = false;
                isFirefox = false;
            }
        }
        CellDefaultType = isMobile && isFirefox ? Cell.InputTypeNumber : Cell.InputTypeText;

        utilitiesModule = await JS.ImportAsync(JSModules.UtilitiesModule);
        await FetchSavedState();
    }

    protected override void OnAfterRender(bool firstRender)
    {
        if (!firstRender) return;
        if (settingsProvider is null) return;
        settingsProvider.AfterSettingsLoaded += OnAfterSettingsLoaded;
    }

    private void OnAfterSettingsLoaded()
    {
        if(settingsProvider is not null)
        {
            targetBlanks = settingsProvider.GetInt(SettingsProvider.DesiredBlankCells);
            attemptsToRemove = settingsProvider.GetInt(SettingsProvider.CellBlankingAttempts);
        }
        CreateNewBoard();
    }

    private async ValueTask FetchSavedState()
    {
        if (utilitiesModule is null) return;
        lastSavedState = await utilitiesModule.GetSettingAsync<string>(SudokuStateKey);
    }

    private async Task Save()
    {
        if (utilitiesModule == null) return;

        string savedState = BoardSerializer.SerializeToJson(board, timer?.SpanToShow, GameStateVersion.Current);
        await utilitiesModule.SetSettingAsync(SudokuStateKey, savedState);
        lastSavedState = savedState;
        await SetStatusMessage("Saved");
    }

    private Task SetStatusMessage(string messageKey)
    {
        CancelMessageClear();
        StatusMessage = Loc[messageKey];
        return Task.Delay(TimeSpan.FromSeconds(4), cts.Token).ContinueWith(t =>
        {
            if (t.IsCanceled) return;
            StatusMessage = string.Empty;
        });
    }

    private void CancelMessageClear()
    {
        cts?.Cancel();
        cts?.Dispose();
        cts = new();
    }

    private async Task Load()
    {
        if (utilitiesModule == null) return;

        lastSavedState ??= await utilitiesModule.GetSettingAsync<string>(SudokuStateKey);
        if (await LoadV2()) return;
        await LoadV1();
    }

    private async Task<bool> LoadV2()
    {
        if (lastSavedState == null) return false;
        var loadedBoard = BoardSerializer.DeserializeFromJson(lastSavedState, out var loadedTimer);
        if (loadedBoard == null || !loadedTimer.HasValue) return false;

        board = loadedBoard;
        timer?.SetTime(loadedTimer.Value);
        InvalidCells = board.GetInvalidCells(SudokuValidator);
        await SetStatusMessage("Loaded");
        return true;
    }

    private async Task<bool> LoadV1()
    {
        if (lastSavedState == null) return false;
        if (utilitiesModule == null) return false;
        var v1board = BoardSerializer.DeserializeFromJson(lastSavedState);
        var jsonTimer = await utilitiesModule.GetSettingAsync<string>(TimerStateKey);
        if (v1board == null || timer == null || jsonTimer == null || !TimeSpan.TryParse(jsonTimer, out var loadedTimerOnly))
            return false;

        board = v1board;
        timer.SetTime(loadedTimerOnly);
        InvalidCells = board.GetInvalidCells(SudokuValidator);
        await SetStatusMessage("Loaded");
        return true;
    }

    protected void CreateNewBoard()
    {
        success = false;
        board = new Board(Solver, new RandomOptionOrder<int>(), Blanker, targetBlanks, attemptsToRemove);
    }

    private async Task HandleKeyDown(KeyboardEventArgs args, int row, int column)
    {
        if (keyHandler == null) return;
        if (args.AltKey || args.ShiftKey || args.MetaKey || args.CtrlKey) return;
        await keyHandler.Handle(args, row, column);
    }

    private async Task ProcessNonNavigatingInputAsync(KeyboardEventArgs args, int row, int column)
    {
        row -= 1;
        column -= 1;

        if (board.IsPredefined((row, column))) return;
        string key = args.Key;
        if (int.TryParse(key, out var number) && number >= 1 && number <= 9)
        {
            UpdateCellAsync(row , column, cells[row, column], number);
            CheckForWinCondition();
        }
        else
        {
            await cells[row, column].SetParametersAsync(ParameterView.FromDictionary(new Dictionary<string, object?> { { nameof(Cell.Value), string.Empty } }));
            board.ClearCell((row, column));
            InvalidCells.Remove((row, column));
            InvalidCells.RemoveAll(cell => SudokuValidator.IsValid(board, cell));
        }
    }

    private void UpdateCellAsync(int row, int column, Cell currentCell, int number)
    {
        board.FillCell((row, column), number);
        currentCell.OnChange(number.ToString());
        InvalidCells = board.GetInvalidCells(SudokuValidator);
    }

    private void CheckForWinCondition()
    {
        if (board.EmptyCells.Count == 0 && SudokuValidator.IsValidBoard(board))
        {
            success = true;
            timePassed = timer?.SpanToShow;
        }
    }

    private async Task LoadResourcesAsync()
    {
        await Loc.InitializeAsync(Layout.Culture);
        StateHasChanged();
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        Layout.OnStateChanging -= LoadResourcesAsync;
        cts?.Dispose();
        if (settingsProvider is not null)
            settingsProvider.AfterSettingsLoaded -= OnAfterSettingsLoaded;
        if (module is null) return;
        await module.DisposeAsync();
    }
}
